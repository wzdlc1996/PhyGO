# 浮点数

二进制表示的局限
1.  并不是所有十进制小数都能用有限长的二进制浮点数表示. (一定存在, 整数不会有这个问题)
2.  给定长度的二进制序列, 定点(fix point)表示会十分受限(最大值和最小值(正)固定)

浮点数就来自于试图解决上面的第二个局限. (floating point/float) 的名字也来自这里.

[IEEE 浮点数的标准(754)](https://en.wikipedia.org/wiki/IEEE_754)

缺点:

1.  rounding, overflow, underflow的问题
2.  硬件实现不够快(相对整型运算). (最近的神经网络需求(相对robust, 精度容忍程度高)给出了其他要求)

浮点计算的警惕案例:
浮点 -> 整型的转换需要十分小心.
1.  5亿美元的火箭
2.  爱国者导弹的灾难(20人死亡)

## 浮点数的编码

二进制科学计数法:

$$1.1101101101101_2 \times 2^{13}$$

通过使用整型表示significand 和 exponent, 能够表达一个浮点数(小数点的浮动在于exponent的不同取值)

一般的, 给出 $(-1)^s M \times 2^{e}$ 的二进制科学计数法, 它的编码被实现为一个组 $(s, exp, frac)$. 对于通常的float32类型, s占1位, exp 占8位而 frac 占据23位. 其中 $(e, M)$ 和 $(exp, frac)$ 的对应关系即浮点数编码模式, 如下:

浮点数的编码分为三类(这种判断过程拖慢硬件实现):

1.  normalized value
    1.  如果 exp 表示的数位不全为0也不全为1
    2.  使用bias来进行编码, 对float32类型, $e = exp - 127$, 使得其值域对应为 $e\in [-126, 127], exp\in [1, 254]$
    3.  frac位首位一定是1, 因此实际表示中只保留小数位. 换言之, $M = 1.frac$

2.  denormalized value
    1.  如果 exp 全为0且 frac不全为0
    2.  实际的 exp 为 1 - bias, 比如float32为 -126
    3.  $M=0.frac$

3.  special value
    1.  exp 全为1, frac 全为1, 给出infinity
    2.  exp 全为1, frac 不全为1, 这些表示被舍弃
    3.  exp 全为0, frac 全为0, 它们根据符号位表示 $\pm 0$

IEEE 754 的一些性质:

1.  全数位为0的浮点数代表0
2.  比较大小时, 可以预先使用两个 exp 做无符号整数比较. 

## 浮点数的计算

### 舍入

采取 round to even 策略. 比如(1.5 -> 2, 2.4 -> 2, 2.5 -> 2)

所有浮点运算操作, 均可理解为首先计算出精确值, 然后加入舍入使其能够在浮点表示下给出表示. 


