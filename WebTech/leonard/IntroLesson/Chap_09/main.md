# 互联网应用模式

## 网络性能

网络性能的度量

1.  延迟(delay): 网络传输数据的时间
2.  吞吐率(throughput): 单位时间能够传输的数据量
3.  抖动(jitter): 延迟的变化量和持续时间

### 延迟

传输延迟: 传输介质传输信息的时间
接入延迟: 共享介质(如总线)中的竞争时间
交换延迟: 交换机和路由器在发送分组前必须等分组所有位到达, 以及选择下一站的时间
排队延迟: 分组在交换机和路由器的存储器中排队等待发送的时间
服务器延迟: 服务器对一个请求的响应时间和发送反馈的时间

### 吞吐率和容量

通常称为网络带宽或速度. 同延迟不同, 吞吐率描述单位时间有多少信息能够被传输(单位时间有多少车能进入一条路), 延迟描述这些信息要花多久能得到反馈(一辆车花多久能走完路)

吞吐率的最大值被称为 **容量(capacity)**

延迟和吞吐率理论上(似乎)是独立的(可以证明理论上也是不独立的), 但事实上是相关的. 存在如下概念:

1 - 当前网络利用率 = 有效延迟 / 空闲延迟

随着业务量增加, 延迟随之增加. 当吞吐率接近满容量时, 网络会经受非常大的延迟.

### 抖动

抖动是对延迟变化量的度量. 对于音视频流传输来说, 抖动比延迟更重要

处理抖动的办法
1.  设计一个无抖动的等时网络, 如传统的电话系统
2.  采用能补偿抖动的协议, 在internet上传播语音/视频, 一般使用 **实时协议(real-time protocol)**. 协议存在能应对的最大抖动

### 网络性能测量

测量这几个指标十分困难
1.  路径可能不对称: 可能无法用往返时间衡量延迟
2.  网络条件急剧改变: 性能的准确值难以测量
3.  测量影响性能: 观察者效应. 测量加重网络负担
4.  业务是突发的: 数据网络是突发(bursty)的, 流量是不均匀的.

### 服务质量(QoS)

细粒度: 提供商允许客户为特定通信实例生命具体的QoS需求. 客户每次创建一个流的时候做一次请求
粗粒度: 提供商把服务规定为几种大类, 每一类适合一种业务流类型. 客户必须让所有的业务流都适合某种类型的服务.

长年开发研究总结, 细粒度一般是不必要的. 细粒度一般适合的是局域网场景.

交换机或路由器实现QoS的关键步骤:

(到达分组) -> 分类与监管 -> 转发计算 -> 输出排队 -> 流量调度 -> (离开的分组)

## 互联网的脆弱性

网络安全四要素: 脆弱性评估, 入侵检测系统, 防火墙, 病毒检测

脆弱性评估的目的: 不是完全消除脆弱性, 而是提供一个安全的解决方案. 

1.  IP路由机制: 数据报方式, 根据最终目的地选择合适的下一站, 不检查源地址(每个路由器都要检查每个IP数据报的话代价很大), 路径追溯很难(转发路由没有邮戳, 实际操作时追踪一次要涉及多个组织)
2.  拒绝服务攻击: DoS, 向目标服务器发送大量虚假请求, 服务器应答被这些请求占满无法为合法用户服务. DDoS(分布式DoS, 使用木马程序等控制大量服务器组成攻击集群), 理论上区分DDoS攻击和合法的过载是不可能的.
3.  DNS攻击: 攻击有限的DNS服务器. 后果会将互联网变成一个个大局域网.
4.  基于ARP的攻击: 伪装合法主机, 伪装合法网桥, MAC flooding.

## 互联网应用模式

### 客户/服务器模式

网络应用系统为用户提供了高层服务, 并决定了用户对底层互联网络能力的认知.

应用程序要确定信息显示的格式以及用户选择和访问信息的机制. 最重要的, 应用能定义 **符号名字** 来标识互联网上可用的物理资源和抽象资源

互联网提供一个底层的通信架构, 如何运行这些服务, 确定服务的存在, 以及如何使用这些服务这些问题都留给了应用软件和用户. 

客户与服务器的特性:
1.  客户端
    -  需要进行远程访问时暂时成为客户, 同时要完成本地计算任务
    -  直接被用户调用
    -  一般在本地运行
    -  主动启动和服务器的通信
    -  不需要高级复杂的硬件
2.  服务器
    -  用来提供某种服务, 有特殊权限的专用程序, 可以处理多个请求
    -  自动启动, 不断地为多个会话服务
    -  在一台共享计算机上运行
    -  被动地等待远端请求
    -  需要强大硬件支持.

数据流向: 信息可以单向或双向. 许多服务安排成客户发送一个或多个请求而服务器返回应答.

### 交互与循环依赖问题

客户和服务器之间可以任意交互. 
1.  客户应用不限于只能访问一个服务, 可以访问多个server. 对每种服务, 客户可与不同服务器(可能在不同计算机)进行通信
2.  客户访问某一服务时并不限于一个服务器, 可以通过向多个服务器发送请求以提高性能(以最先返回的为准)

服务器的安排必须经过精心考虑以防止循环依赖. 小规模服务器应答是容易的, 大规模依赖环则不是很明显.

sockets API(套接字API). 最早是BSD, UNIX系统的一部分. 后来成为工业界事实上的标准. socket使用了UNIX I/O的概念, 同文件操作类似.

## 网络应用编程

网络应用中, 网络通信模块往往大同小异. 因此现在有大量工具可以自动生成这些代码(middleware, 中间件)

**远程过程调用(RPC, Remote Procedure Call)**: 不给程序员提供显式的通信原语, 而使用传统编程语言提供接口

程序员一开始只考虑业务逻辑, 完成单机程序后, 划分为客户和服务器, 使用RPC工具

## P2P

概念: peer-to-peer技术, 没有client和server概念, 各节点平等, 都是信息的consumer和provider. 
应用: 目前多用于文件共享和实时多媒体业务

优势: 所有节点都提供资源, 包括带宽, 存储和计算能力
缺点: 占用大量带宽, 可被攻击之处更多, 法律(如版权)和政府限制(信息控制)

未来: 会使用一些非对等单元以及多个协议, 建立混合应用
概念上和C/S之间并没有鸿沟