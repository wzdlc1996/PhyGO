# 快速排序

对于包含 $N$ 个数的输入数组, **快速排序** 是一种最坏情况时间复杂度为 $\Theta(N^2)$ 的排序算法. 尽管如此, 它的期望时间复杂度为 $\Theta(N \log N)$ 而且其中的常数因子非常小, 因此它通常是实际排序应用中的最优选择. 此外它还能够进行原址排序. 

## 快速排序的描述

快速排序的实现如下:

```python{.line-numbers}
def quickSort(arr):
    quickSort(arr, 0, len(arr) - 1)

def quickSort(arr, i, j):
    if i < j < len(arr):
        q = parti(arr, i, j)
        quickSort(arr, i, q - 1)
        quickSort(arr, q, j)

def parti(arr, i, j):
    x = arr[j]
    s = i - 1
    for r in range(i, j):
        if arr[r] <= x:
            s = s + 1
            arr[s], arr[r] = arr[r], arr[s]
    arr[s+1], arr[j] = arr[j], arr[s+1]
    return s + 1
```

可以看到, 快速排序的核心是 `parti` 函数, 它给出分割数组的方案, 并且进行一定的排序任务. 

我们证明如下的循环不变式, 并且利用它证明快速排序的正确性.

> 在13-16行的 for 循环中每一轮的开始, 数组 `arr` 被划分成了4个部分(可能为空), 其中 `x = arr[j]` 被称为主元
> 1.  若 $i\leq n\leq s$, 则 `arr[n] <= x`
> 2.  若 $s+1 \leq n \leq r-1$, 则 `arr[n] > x`
> 3.  若 $n = j$, 则 `arr[n] = x`

1.  **初始化**: 在循环开始时, $s = i-1$, 此时上面不变式中的1,2可被看作成立. 而11行的赋值保证了3成立
2.  **保持**: 考虑某次循环的状态转移, 即 $r \rightarrow r+1$. 此时根据 15行的判断存在两种情况. 

    1.  如果 `arr[r+1]` 不大于主元 `x`, 此时 `s` 被更新为 `s+1`, 而 `arr[r+1]` 和 `arr[s+1]` 的值得到互换. 

        在这样的更新下, 性质1得到保持, 因为互换使得不大于主元的元素被调到前面
        性质2同样得到保持, 互换之下这部分数组被轮换一位且往后平移一位, 而 `s+1:r-1` 同样均增加1.
        性质3不变.

    2.  如果 `arr[r+1]` 大于主元 `x`, 此时 `s` 的值不变, 而 `r` 的值增加1. 因此性质1不变, 性质2增加长度1, 性质3同样不变. 

    因而不变式是保持的

3.  **终止**: 当循环终止时, $r$遍历了 $i$ 到 $j-1$中的所有元素. 此时我们有 $r=j$ (注意我们循环不变式的提法是在每个循环的开始, 因此最后一个循环终止时 $r=j-1$, 而在下一个循环开始(虽然此时不存在这个循环体需要执行), 我们有$r=j$). 从而任何元素都应当属于1,2,3这三个区间中的一个. 此时我们看到数组被分成三个部分:

    $$
    arr[i:s+1] , arr[s+1:j], arr[j]
    $$

    分别是不大于 $x$, 大于 $x$, 等于 $x$ 三种情况.


我们使用这个循环不变式来证明快速排序的正确性. 在 `parti` 函数的结尾17行, 它让 `arr[s+1]` 和 `arr[j]` 互换, 并且在 18行返回了 `s+1`. 相当于将第二部分的起始和主元互换并且返回了其位置. 因此每次运行 `parti` 函数的效果是让数组变成:

$$
arr[:q]\leq arr[q]< arr[q+1:]
$$

这样的三部分. 而分治法再这样操作上式的两边的子数组. 因此在递归结束的时候, 我们有

$$
arr[0] \leq arr[1]\leq \cdots \leq arr[N-1] 
$$

即数组被排好序. 

