# 快速排序

## 快速排序的性能

1.  **最坏情况**
    快速排序的坏情况发生在分治法产生划分是产生的是两个极端不平衡的划分, 即分出的两个部分的长度分别为 $N-1$ 和 $1$ (主元位置). 

    最坏情况发生在每一层的子问题都是如此的情况, 这种情况可以出现在待排序数组已经完全排好序时, 此时分割子问题将不会对数组作出任何操作然后分成 $n-1$ 与 $1$ 的两部分. 最坏情况的时间复杂度由如下递归方程确定:

    $$
    T(n) = T(n-1) + \Theta(n) \ ; \ T(1) = \Theta(1).
    $$

    其中的 $\Theta(n)$ 来自于 `parti` 子程序中的循环比较. 该递归方程的解为 $T(n) = \Theta(n^2)$. 

2.  **最好情况**
    快速排序的最好情况来自每次都给出均衡划分的情况, 此时其时间复杂度的递归方程为
    $$
    T(n) = 2T(n/2) +\Theta(n)\Rightarrow T(n) = \Theta(n\log n)
    $$

3.  **一般的划分, 快速排序的优势**
    快速排序算法拥有着特别的性质, 如果每层递归的划分都并不是最均衡的情况, 如分成 $cn$ 和 $(1-c)n$ 两部分, 从而时间复杂度的递归方程为

    $$
    T(n) = T(cn) + T((1-c)n) + \Theta(n)
    $$

    我们同样能够证明其对应的时间复杂度之解为 $T(n)=O(n\log n)$, 为此我们使用归纳法证明:

    $$
    \begin{aligned}
    T(n) &= O(cn \log cn) + O((1-c)n \log (1-c)n) + \Theta(n) \\
    &= O(cn \log n + cn \log c + (1-c)n \log n + (1-c)n \log (1-c)) + \Theta(n) \\
    &= O(n\log n)
    \end{aligned}
    $$

    
